#!/usr/bin/env python


import os
import subprocess as sp
import sys
from argparse import ArgumentParser
from collections import defaultdict
from operator import itemgetter
from shutil import rmtree
from tempfile import mkdtemp
from Bio import SeqIO

def parseArgs():
	parser = ArgumentParser(description='Converts a BLAST outfmt 6 alignment '
		'file generated by ANIb+ into a BED file, which is a tab-delimited '
		'list of sequence record names (1st col), bidirectional alignment '
		'coordinates (2nd and 3rd cols), a feature label (4th col), their '
		'corresponding percent identity values (5th col), and strand (6th '
		'col). Requires Bedtools', add_help=False,
		epilog='NOTE: alignment sequence record names must be labeled '
		'<sample>__frg<int>__pos<start>-<stop>')
	req = parser.add_argument_group('Required')
	req.add_argument('-i', '--infile', metavar='FILE', required=True,
		help='input FastA Format file')
	opt = parser.add_argument_group('Optional')
	opt.add_argument('-h', '--help', action='help',
		help='show this help message and exit')
	opt.add_argument('-o', '--outfile', metavar='FILE',
		default=None, help='output BED Format file [stdout]')
	opt.add_argument('-s', '--sample', default=1, type=int,
		choices=[1, 2], help='column number to parse for sample [1]')
	opt.add_argument('--col4', metavar='STR', default=None,
		help='fill 4th column with string [filename]')
	return parser.parse_args()

def collapse_alignment_records(recs):
	''' given a list of tuples containing blast alignment records,
	collapse overlapping alignment ranges and merge percent identity values,
	returns a list of tuples '''
	# tuples = (float(identity), int(aln_len), str(strand), int(aln_start), int(aln_stop)

	aln_recs_coord_sorted = sorted(recs, key=itemgetter(3, 4), reverse=True)
	
	collapsed_aln_recs = []
	for i, aln_len in enumerate(aln_recs_coord_sorted):
		identity, aln_len, _, start, stop = aln_recs_coord_sorted.pop(0)
		if start <= aln_rec[4]: #overlap
			while start <= aln_rec[4]:
				sum_aln_lengths = aln_len + int(aln_rec[1])
				sum_of_products = ((identity/100.0 * aln_len) +
					aln_rec[0]/100.0 * int(aln_rec[1]))
				merged_identity = sum_of_products / sum_aln_lengths
				identity, aln_len, strand, start, stop = \
					merged_identity, sum_aln_lengths,
					'+', aln_rec[3], stop
				i -= 1
			collapsed_aln_recs.append(aln_rec)
		else: #no overlap
			collapsed_aln_recs.append(aln_rec)
			identity, aln_len, strand, start, stop = aln_rec
		i =+ 1
	return collapsed_aln_recs



	for aln_rec in aln_recs_coord_sorted:
		if start <= aln_rec[4]: #overlap
			while start <= aln_rec[4]:
				sum_aln_lengths = aln_len + int(aln_rec[1])
				sum_of_products = ((identity/100.0 * aln_len) +
					aln_rec[0]/100.0 * int(aln_rec[1]))
				merged_identity = sum_of_products / sum_aln_lengths
				identity, aln_len, strand, start, stop = \
					merged_identity, sum_aln_lengths,
					'+', aln_rec[3], stop
			collapsed_aln_recs.append(aln_rec)
		else: #no overlap
			collapsed_aln_recs.append(aln_rec)
			identity, aln_len, strand, start, stop = aln_rec
	return collapsed_aln_recs

def main():
	opt = parseArgs()
	ifh = os.path.abspath(os.path.expanduser(opt.infile))
	tmp = mkdtemp()

	if opt.col4 is not None:
		feat_label = str(opt.col4)
	else:
		feat_label = os.path.basename(ifh)

	# Step1 transform blast data into start/stop positions of initial infile seq
	d = defaultdict(list) # key=seqID: val=list of tuples containing (%ID, aln-len, strand, start-pos, stop-pos)
	with open(ifh) as aln_file:
		for ln in aln_file:
			l = ln.split('\t')
			sample_name = str(l[opt.sample - 1].split('__')[0])
			fragment_start_position = int(l[opt.sample - 1].\
				split('__pos')[1].split('-')[0])
			identity = l[2]
			aln_len  = l[3]
			if opt.sample == 1:
				idx_start, idx_stop = 6, 7
			elif opt.sample == 2:
				idx_start, idx_stop = 8, 9
			aln_start = int(l[idx_start]) + fragment_start_position
			aln_stop  = int(l[idx_stop])  + fragment_start_position
			strand = '+'
			if aln_start > aln_stop:
				strand = '-'
				aln_start, aln_stop = aln_stop, aln_start
			d[sample_name].append((float(identity), int(aln_len), str(strand),
					int(aln_start), int(aln_stop)))
	
	# Step2 for each initial infile defline merge/collapse those with overlapping coordinates
	o = {}
	for k, v in sorted(d.items()):
		if len(v) > 1:
			aln_records = collapse_alignment_records(v)
			o[k] = aln_records
		else:
			o[k] = v

	tempfile = os.path.join(tmp, 'coords')
	with open(tempfile, 'w') as tfh:
		for ln in o:
			tfh.write(ln)

	if opt.outfile is not None:
		ofh = open(os.path.abspath(os.path.expanduser(opt.outfile)), 'w')
	else:
		ofh = sys.stdout

	srt = sp.Popen(['bedtools', 'sort', '-i', tempfile], stdout=sp.PIPE)
	mrg = sp.Popen(['bedtools', 'merge', '-c', '5', '-o', 'mean', '-i', 'stdin'],
		stdin=srt.stdout, stdout=sp.PIPE)
	with open(os.path.join(outpath, os.path.basename(f)), 'w') as ofh:
		ret = sp.Popen(['sort', '-V'], stdin=mrg.stdout, stdout=ofh)

if __name__ == '__main__':
	main()
